`mod` is a function performing the modulo operation on two numbers, for example

`mod 5 2 == 1`

`mod 8 5 == 3`

The following expression is a list of all odd natural numbers with `nat` defined as `nat = [0..]`.

`[x | x <- nat, mod x 2 == 1]`

The expression above corresponds with the following set-builder notation in mathematics.

![Odd Numbers](__QPATH__/equation.svg 'Odd Numbers')

Such expression in Haskell is called a list comprehension, which has the following form.

`[expression | qualifier0, qualifier1, ..., qualifierN]`

An qualifier can be a generator of the form `variable <- list`. It can also be a guard which is an expression of type `Bool`. The variable name appeared at the left-had-side of a generator can be used in successive guards or the expression on the left of the vertical bar `|`.

A simple list comprehension like `[e | v <- l, cond]` can be interpreted as evaluating `e` for every `v` which is taken from `l` and makes `cond` evaluate to `True`, and then collecting the results in a new list. This interpretation can be generalised to list comprehensions with more qualifiers.

More examples of list comprehensions:

`take 5 [x * 2 | x <- [0..]] == [0, 2, 4, 6, 8]`

```
[[x, y] | x <- [1, 2, 3], y <- [4, 5]]
  == [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
```

```
[[x, y] | x <- [0..13], y <- [0..13], x * x + y * y == 169]
  == [[0, 13], [5, 12], [12, 5], [13, 0]]
```

`[x | x <- []] == []`

---

Some useful functions:

- `abs`: Get the absolute value of a number.  
  `abs 0 = 0`  
  `abs (-2.5) == 2.5`  
  `abs 3 == 3`

- `quot`: Integer division.  
  `quot 6 2 == 3`  
  `quot 5 2 == 2`

- `sqrt`: Get the square root of a real number.  
   `sqrt 5 == 5 ** 0.5`

- `round`: Get the nearest integer of a real number.  
  `round 2.0 == 2`  
  `round 3.5 == 4`  
  `round 3.1 == 3`

- `ceiling`: Get the smallest integer greater than or equal to a real number.  
  `ceiling 2.0 == 2`  
  `ceiling 3.5 == 4`  
  `ceiling 3.1 == 4`

- `floor`: Get the largest integer less than or equal to a real number.  
  `floor 2.0 == 2`  
  `floor 3.5 == 3`  
  `floor 3.1 == 3`

- `fromIntegral`: Convert an integer to a real number.  
  `fromIntegral (2 :: Int) == (2.0 :: Double)`

A Pythagorean triple is three integers `[a, b, c]` satisfying the following relationship:

`a * a + b * b == c * c`

If `[a, b, c]` is a Pythagorean triple, `[b, a, c]` will be considered as a repetitive one.

Pythagorean triples can be generated with the following rule (Dickson's method):

Pick an positive even integer `r`, then find another two positive integers `s` and `t` so the following relationship holds.

`r * r == 2 * s * t`

And then `[r + s, r + t, r + s + t]` is a Pythagorean triple.

Replace the missing parts (indicated with `??`) in the following code, so the expression `triples r` evaluates to a list of all nonrepetitive Pythagorean triples generated by `r` which is **guaranteed to be a positive even integer**.

Example:

```
triples 8
  == [[9, 40, 41], [10, 24, 26], [12, 16, 20]]
```

_Hint: a list of a single element is still a list_
